js> Object.keys;
function keys() { [native code for Object.keys, arity=1] }
js> Object.keys() === undefined;
true
js> [undefined, null, true, 1, "hello"].forEach(function(val) {
  >   try {
  >     Object.keys(val);
  >     print("Object.keys("+val+") should have thrown a TypeError");
  >   } catch (e if e instanceof TypeError) {
  >     // this was expected
  >   } catch (e) {
  >     print("Object.keys("+val+") should have thrown a TypeError, but instead threw "+e)
  >   }
  > })

js> Object.keys({}).toSource();
[]
js> Object.keys({a:2}).toSource();
["a"]
js> Object.keys({a:1, b:2}).toSource();
["a", "b"]
js> Object.keys({'a.b':1, 'c d':2}).toSource();
["a.b", "c d"]

js> Object.keys([]).toSource();
[]
js> Object.keys(['a', 'b', 'c']).toSource();
[0, 1, 2]

js> function UserDefined() { this.a = 1; this.b = 2 };
js> var obj = new UserDefined()
js> Object.keys(obj).toSource()
["a", "b"]

js> UserDefined.prototype.c = 3;
3
js> Object.keys(obj).toSource()
["a", "b"]

js> // test properties of result are enumerable
js> for (var p in Object.keys({a:2, b:3})) print(p)
0
1

js> // test that properties of result are writable
js> var k = Object.keys({a:2, b:3});
js> k[1] = 'c'; k.toSource();
["a", "c"]

js> // test that properties of result are configurable
js> var k = Object.keys({a:2, b:3})
js> delete k[1];
true
js> k
a,
js> // TODO test that the attributes of the properties can be changed
